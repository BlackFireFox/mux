#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys,os,urllib,re,time,readline
from pygame import mixer
if os.name=="nt":
	print "Windows isn't supported."
	SystemExit
v="1.2"
class bcolors:
	HEADER = '\033[95m'
	OKBLUE = '\033[94m'
	OKGREEN = '\033[92m'
	WARNING = '\033[93m'
	FAIL = '\033[91m'
	ENDC = '\033[0m'
	BOLD = '\033[1m'
	UNDERLINE = '\033[4m'
	BL = '\033[30m'
	BW = '\033[47m'
def trow():
	return int(os.popen('stty size','r').read().split()[0])
def tcol():
	return int(os.popen('stty size','r').read().split()[1])
def cls():
	os.system('cls' if os.name=='nt' else 'clear')
def hr():
	#return "-"*tcol()
	return "â”€"*tcol()
clist=[".history",".history -c","s",".set","exit",".exit","quit",".quit",".v"]
for a in range(50):
	clist.append(str(a))
	clist.append("d "+str(a))
class MyCompleter(object):  # Custom completer
	def __init__(self, options):
		self.options = sorted(options)
	def complete(self, text, state):
		if state == 0:  # on first trigger, build possible matches
			if text:  # cache matches (entries that start with entered text)
				self.matches = [s for s in self.options 
									if s and s.startswith(text)]
			else:  # no text entered, all matches possible
				self.matches = self.options[:]
		# return match indexed by state
		try: 
			return self.matches[state]
		except IndexError:
			return None
completer = MyCompleter(clist)
readline.set_completer(completer.complete)
readline.parse_and_bind('tab: complete')
def gv(text):
	return urllib.urlencode({"a":text})[2:]
def ungv(text):
	return urllib.unquote(text.replace("+"," "))
def rr(results,p):
	global st
	global n
	if p=="<":
		if n<=10:
			print "No more page back."
		else:
			cls()
			print st+"\n"+hr()
			tn=n-10
			while n>=0 and n>tn:
				if n%2==0:
					print bcolors.BW+bcolors.BL+str(n)+"-"+"".join(re.findall('&raquo;">(.*?)</a>',r[n]))+"-"+"".join(re.findall('&ndash; (.*?)</span>',r[n]))+"-"+"".join(re.findall('span class="dur">(.*?)</span>',r[n]))+bcolors.ENDC
				else:
					print str(n)+"-"+"".join(re.findall('&raquo;">(.*?)</a>',r[n]))+"-"+"".join(re.findall('&ndash; (.*?)</span>',r[n]))+"-"+"".join(re.findall('span class="dur">(.*?)</span>',r[n]))
				n-=1
			print "< page "+str(n/10)+"/"+str(len(results)/10)+" >"
	else:
		if n>=len(results):
			print "No more page."
		else:
			cls()
			print st+"\n"+hr()
			tn=n+10
			while n<len(results) and n<tn:
				if n%2==0:
					print bcolors.BW+bcolors.BL+str(n)+"-"+"".join(re.findall('&raquo;">(.*?)</a>',r[n]))+"-"+"".join(re.findall('&ndash; (.*?)</span>',r[n]))+"-"+"".join(re.findall('span class="dur">(.*?)</span>',r[n]))+bcolors.ENDC
				else:
					print str(n)+"-"+"".join(re.findall('&raquo;">(.*?)</a>',r[n]))+"-"+"".join(re.findall('&ndash; (.*?)</span>',r[n]))+"-"+"".join(re.findall('span class="dur">(.*?)</span>',r[n]))
				n+=1
			print "< page "+str(n/10)+"/"+str(len(results)/10)+" >"
def gr(results,num,w):
	wr="".join(re.findall('&raquo;">(.*?)</a>',results[num]))+"-"+"".join(re.findall('&ndash; (.*?)</span>',results[num]))+"-"+"".join(re.findall('span class="dur">(.*?)</span>',results[num]))
	if w=="s":
		return wr.split("-")[0]
	if w=="n":
		return wr.split("-")[1:-1]
	if w=="t":
		return wr.split("-")[-1]
	else:
		return wr
def wsm():
	if not os.path.isfile(os.path.expanduser("~")+"/.mux/set.conf"):
		wsm="./"
	else:
		sett=open(os.path.expanduser("~")+"/.mux/set.conf","r")
		cset=sett.read()
		sett.close()
		wsm="".join(re.findall('saveto=(.*?);',cset))
		if not wsm.endswith("/"):
			wsm+="/"
	return wsm
url="https://petamusic.ru/"
print "Connecting..."
try:
	urllib.urlopen(url)
	print "Ok"
except Exception as e:
	print "Error:\n"+str(e)
	sys.exit()
if os.path.isfile(os.path.expanduser("~")+"/.mux/history.log"):
	whis=open(os.path.expanduser("~")+"/.mux/history.log","a")
e=True
while e:
	cls()
	if tcol()>=17:
		sp=int((tcol()-17)/2)
		print bcolors.OKGREEN+" "*sp+" _  _  _ _ __  __"
		print " "*sp+"| \/ || | |\ \/ /"
		print " "*sp+"|    || | | \  /"
		print " "*sp+"| \/ || | | /  \\"
		print " "*sp+"|_||_||___|/_/\_\\"
		print " "*sp+"music plyr/dwnldr"+bcolors.ENDC
	else:
		sp=int((tcol()-3)/2)
		print bcolors.OKGREEN+" "*sp+"MUX"+bcolors.ENDC
	if os.path.isfile("/usr/local/bin/mux"):
		print " "*int((tcol()-len("v"+v))/2)+bcolors.OKBLUE+"v"+v+bcolors.ENDC
	else:
		print " "*int((tcol()-len("v"+v+" not installed"))/2)+bcolors.OKBLUE+"v"+v+bcolors.FAIL+" not installed"+bcolors.ENDC
	q=raw_input("Search: ")
	if q==".set":
		cls()
		if not os.path.isfile(os.path.expanduser("~")+"/.mux/set.conf"):
			sett=open(os.path.expanduser("~")+"/.mux/set.conf","w+")
			sett.write("user="+os.environ["USER"]+";\ninstalled="+time.time()+";saveto=.;")
			sett.close()
		print "Settings ("+os.path.expanduser("~")+"/.mux/set.conf):"
		sett=open(os.path.expanduser("~")+"/.mux/set.conf","r")
		cset=sett.read()
		sett.close()
		ocs="".join(re.findall('saveto=(.*?);',cset))
		print "Save music at:",ocs
		cs=raw_input("Change with: ")
		cs.replace("~",os.path.expanduser("~"))
		if cs=="":
			cs=ocs
		cset=cset.replace("saveto="+ocs+";","saveto="+cs+";")
		sett=open(os.path.expanduser("~")+"/.mux/set.conf","w")
		sett.write(cset)
		sett.close()
		raw_input("<ENTER> to continue")
	elif q==".v":
		print "You are using: "+bcolors.OKBLUE+"v"+v+bcolors.ENDC
		llc=urllib.urlopen("https://raw.githubusercontent.com/BlackFireFox/mux/master/mux").read()
		lc=llc.replace("\n","")
		if not 'v="' in lc:
			lv="0.1"
		else:
			for line in llc.splitlines():
				if 'v="' in line:
					lv="".join(re.findall('v="(.*?)"',line))
					break
		print "Latest: "+bcolors.OKBLUE+"v"+lv+bcolors.ENDC
		if float(v)<float(lv):
			print bcolors.FAIL+"Your software isn't up to date."+bcolors.ENDC
			up=raw_input("Update? [y or n]: ")
			if up.lower()=="y" or up.lower()=="yes":
				try:
					print "Update..."
					os.system("git clone https://github.com/BlackFireFox/spyder temp && cd temp/ && mv ../temp/* .. && rm -rf ../temp")
					print "Completed."
					print "To install updates run:\nsudo make reinstall"
				except:
					print "Git not installed."
					print "Go here for download:"
					print "https://github.com/BlackFireFox/mux"
		else:
			print bcolors.OKGREEN+"Your software is up to date."+bcolors.ENDC
		raw_input("<ENTER> to continue")
	elif q==".history":
		cls()
		if not os.path.isfile(os.path.expanduser("~")+"/.mux/history.log"):
			open(os.path.expanduser("~")+"/.mux/history.log","w+").close()
		print "History ("+os.path.expanduser("~")+"/.mux/history.log):"
		his=open(os.path.expanduser("~")+"/.mux/history.log","r")
		print his.read()
		his.close()
		raw_input("<ENTER> to continue")
	elif q==".history -c":
		if not os.path.isfile(os.path.expanduser("~")+"/.mux/history.log"):
			open(os.path.expanduser("~")+"/.mux/history.log","w+").close()
		his=open(os.path.expanduser("~")+"/.mux/history.log","w")
		his.write("")
		his.close()
	elif q==".exit" or q==".quit":
		whis.close()
		print "Bye."
		sys.exit()
	else:
		whis.write(str(time.time())+" - Looking for: "+q+"\n")
		print "Connecting..."
		html=urllib.urlopen(url+"?string="+gv(q)).read().replace("\n","")
		ul="".join(re.findall('<ul class="results">(.*?)</ul>',html))
		r=re.findall('&amp;sort=artist" title="(.*?)</li>',ul)
		d=re.findall('</a> <a class="link" href="(.*?)" title="',ul)
		if len(r)==0:
			print 'No results for "'+q+'"'
		else:
			global st
			st=str(len(r))+' results for "'+q+'"'
			global n
			n=0
			com="..."
			while com!="s":
				if com=="...":
					rr(r,"")
				com=raw_input("> ")
				if com=="exit" or com==".exit" or com=="quit" or com==".quit":
					whis.close()
					print "Bye."
					sys.exit()
				elif com=="s":
					SystemExit
				elif com=="<" or com==">":
					rr(r,com)
				elif com.startswith("d "):
					try:
						if int(com.split(" ")[1])<len(r):
							whis.write(str(time.time())+" - Download: "+wsm()+ungv(d[int(com.split(" ")[1])].split("/")[-1]))
							print "Downloading number '"+com.split(" ")[1]+"' to '"+wsm()+ungv(d[int(com.split(" ")[1])].split("/")[-1])+"'..."
							f=open(wsm()+ungv(d[int(com.split(" ")[1])].split("/")[-1]),"w")
							f.write(urllib.urlopen("https:"+d[int(com.split(" ")[1])]).read())
							f.close()
							print "Ok"
						else:
							print "'"+com.split(" ")[1]+"' out of index."
					except:
						print "'"+com.split(" ")[1]+"' out of index."
				elif com.isdigit():
					if int(com)<len(r):
						try:
							whis.write(str(time.time())+" - Play: "+ungv(d[int(com)].split("/")[-1]))
							print "Playing '"+ungv(d[int(com)].split("/")[-1])+"'"
							print gr(r,int(com),"")
							f=open("/tmp/"+ungv(d[int(com)].split("/")[-1]),"w")
							f.write(urllib.urlopen("https:"+d[int(com)]).read())
							f.close()
							mixer.init()
							mixer.music.load("/tmp/"+ungv(d[int(com)].split("/")[-1]))
							mixer.music.play()
							start=time.time()
							durat=int(gr(r,int(com),"t").split(":")[0])*60+int(gr(r,int(com),"t").split(":")[1])
							while time.time()-start<=durat:
								ts=str(int(time.time()-start))+"/"+str(durat)+" "+str((int(time.time()-start)*100)/durat)+"%"
								bar="["+"="*((((tcol()-len(ts)-2)*(int(time.time()-start)*100)/durat))/100)
								print ts+bar+" "*(tcol()-len(ts)-len(bar)-1)+"]"+"\r",
								sys.stdout.flush()
								time.sleep(1)
							print "\nEnd."
						except KeyboardInterrupt:
							print "\nStop."
							mixer.music.stop()
							if os.path.isfile("/tmp/"+ungv(d[int(com)].split("/")[-1])):
								os.remove("/tmp/"+ungv(d[int(com)].split("/")[-1]))
					else:
						print "'"+com+"' out of index."
				else:
					print "'"+com+"' not found."